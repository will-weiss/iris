{{! Variable and section nodes use a path to traverse the given context to reach a given value }}
{{! If there are no keys to traverse, set the cursor to be equal to the provided data }}
{{! If there are keys to traverse, start at the initial context and traverse the provided keys }}
{{#path}}
  cursor =
    {{^keys}}
      data
    {{/keys}}
    {{#keys.length}}
      context
      {{#keys}}
        , cursor = cursor && cursor["{{{.}}}"]
      {{/keys}}
    {{/keys.length}}
  ;
{{/path}}

{{! For non-section nodes, add to the result in a manner determined by the type of node }}
{{^section}}

  {{{addToResultLeft}}}

    {{! For linestart nodes, add the indentation level }}
    {{#linestart}}
      indentation
    {{/linestart}}

    {{! For newline nodes, add a newline }}
    {{#newline}}
      "\n"
    {{/newline}}

    {{! For text nodes, add the text value of the node }}
    {{#text}}
      {{{text}}}
    {{/text}}

    {{! For variable nodes, add the value of the cursor, optionally escaped }}
    {{#variable}}
      cursor == null
        ? ""
        : ("" + cursor){{#escaped}}
            .replace("&", "&amp;").replace('"', "&quot;").replace("<", "&lt;").replace(">", "&gt;")
          {{/escaped}}
    {{/variable}}

    {{! For partial nodes, add the value of the cursor, optionally escaped }}
    {{#partial}}
      typeof {{{name}}} !== "function"
        ? ""
        : {{{name}}}(data, "{{{indentation}}}")
    {{/partial}}

  {{{addToResultRight}}};
{{/section}}

{{#section}}
  {{^inverted}}
    if (cursor) {
      (Array.isArray(cursor) ? cursor : [cursor]).forEach(function(data) {
        var cursor;
        var context = data && typeof data === 'object' ? Object.assign(Object.create(this), data) : this;
        {{#nodes}}
          {{> node}}
        {{/nodes}}
      }, context);
    }
  {{/inverted}}

  {{#inverted}}
    if (!cursor || cursor.length === 0) {
      {{#nodes}}
        {{> node}}
      {{/nodes}}
    }
  {{/inverted}}
{{/section}}